<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Harvey's Farting Plane!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            font-family: 'Comic Sans MS', Arial, sans-serif;
        }

        body {
            background-color: #1a2f4d; /* Solid fallback for Safari */
            background: linear-gradient(to bottom, #0a1e3d 0%, #1a2f4d 40%, #0f1922 100%);
            background-attachment: fixed;
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-background-size: cover;
            -moz-background-size: cover;
            -o-background-size: cover;
            background-size: cover;
            min-height: 100vh;
            min-width: 100vw;
        }

        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
            text-align: center;
        }

        #startScreen h1 {
            color: white;
            font-size: min(15vw, 80px);
            margin-bottom: 30px;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.6);
            line-height: 1.2;
        }

        #startScreen p {
            color: white;
            font-size: min(6vw, 32px);
            margin: 20px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
        }

        .bigButton {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: min(6vw, 40px) min(12vw, 80px);
            font-size: min(8vw, 48px);
            border-radius: 60px;
            margin: 20px;
            font-weight: bold;
            box-shadow: 0 10px 30px rgba(245, 87, 108, 0.6);
            font-family: 'Comic Sans MS', sans-serif;
            cursor: pointer;
        }

        #gameContainer {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        #plane {
            position: absolute;
            font-size: 60px;
            left: 15%;
            z-index: 10;
            filter: drop-shadow(4px 4px 8px rgba(255, 150, 0, 0.6));
        }

        .fart {
            position: absolute;
            font-size: 50px;
            animation: fartCloud 1.2s ease-out forwards;
            z-index: 5;
        }

        @keyframes fartCloud {
            0% { opacity: 1; transform: scale(0.5) translateX(0); }
            100% { opacity: 0; transform: scale(2.5) translateX(-150px) rotate(-45deg); }
        }

        .obstacle {
            position: absolute;
            right: -100px;
            font-size: 70px;
            animation: moveObstacle linear;
        }

        .star {
            position: absolute;
            right: -50px;
            font-size: 45px;
            animation: moveStar linear;
        }

        @keyframes moveObstacle {
            from { right: -100px; }
            to { right: calc(100% + 100px); }
        }

        @keyframes moveStar {
            from { right: -50px; }
            to { right: calc(100% + 50px); }
        }

        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: min(6vw, 28px);
            font-weight: bold;
            color: #00d9ff;
            background: rgba(15, 25, 34, 0.95);
            padding: min(4vw, 25px);
            border-radius: 20px;
            border: 3px solid #00d9ff;
            z-index: 100;
            line-height: 1.6;
        }

        #gameOver {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: min(8vw, 50px);
            border-radius: 25px;
            text-align: center;
            z-index: 200;
            box-shadow: 0 15px 50px rgba(0,0,0,0.7);
            border: 5px solid #00d9ff;
            max-width: 90vw;
        }

        #gameOver h2 {
            color: white;
            font-size: min(10vw, 52px);
            margin-bottom: 20px;
        }

        #gameOver p {
            color: white;
            font-size: min(6vw, 32px);
            margin: 15px 0;
        }

        .explosion {
            position: absolute;
            font-size: 100px;
            animation: explode 0.8s ease-out forwards;
            z-index: 50;
        }

        @keyframes explode {
            0% { opacity: 1; transform: scale(0.5); }
            100% { opacity: 0; transform: scale(6) rotate(360deg); }
        }

        .pointPopup {
            position: absolute;
            font-size: 40px;
            font-weight: bold;
            color: #ffeb3b;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            animation: popupFloat 1s ease-out forwards;
            z-index: 60;
        }

        @keyframes popupFloat {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-80px) scale(1.5); }
        }

        .tornado {
            position: absolute;
            font-size: 80px;
            animation: tornadoSpin 2s linear forwards;
            z-index: 55;
        }

        @keyframes tornadoSpin {
            0% { opacity: 1; transform: scale(0.5) rotate(0deg); }
            100% { opacity: 0; transform: scale(3) rotate(1080deg) translateX(-200px); }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>üí® HARVEY'S<br>FARTING PLANE! üí®</h1>
        <p>TAP ANYWHERE TO FART!</p>
        <p>Avoid bad guys üöÅ</p>
        <p>Collect stars ‚≠ê</p>
        <button class="bigButton" onclick="startGame()">TAP TO PLAY!</button>
    </div>

    <div id="gameContainer">
        <div id="score">
            ‚≠ê <span id="scoreValue">0</span><br>
            ‚ù§Ô∏è <span id="lives">3</span>
        </div>
        <div id="plane">‚úàÔ∏è</div>
        <div id="gameOver">
            <h2>AWESOME!</h2>
            <p>Score: <span id="finalScore">0</span> ‚≠ê</p>
            <p>Farts: <span id="totalFarts">0</span> üí®</p>
            <button class="bigButton" onclick="restartGame()">PLAY AGAIN!</button>
        </div>
    </div>

    <script>
        const plane = document.getElementById('plane');
        const gameContainer = document.getElementById('gameContainer');
        const scoreElement = document.getElementById('scoreValue');
        const livesElement = document.getElementById('lives');
        const startScreen = document.getElementById('startScreen');
        const gameOver = document.getElementById('gameOver');
        const finalScore = document.getElementById('finalScore');
        const totalFartsElement = document.getElementById('totalFarts');

        let planeY = 0;
        let velocity = 0;
        const gravity = 0.6;
        const fartBoost = -14;
        let score = 0;
        let lives = 3;
        let gameRunning = false;
        let gameLoop;
        let obstacles = [];
        let stars = [];
        let totalFarts = 0;

        // SHARED AUDIO CONTEXT for iOS compatibility
        let sharedAudioContext = null;
        let musicOscillators = [];
        let musicInterval = null;

        const fartSounds = ['üí®', 'üí©', 'üå™Ô∏è', '‚òÅÔ∏è'];
        const crashMessages = [
            "Harvey farted too hard!",
            "Too much farting power!",
            "Epic fart crash!",
            "Whoa! That was a big one!",
            "Fart overload!"
        ];
        const funMessages = [
            "Harvey is flying like a champion!",
            "What a pro farter!",
            "Keep those farts coming!",
            "Harvey's on fire!",
            "Amazing flying Harvey!",
            "Woohoo! Great job!",
            "Harvey the fart master!"
        ];

        function fart() {
            if (!gameRunning) return;

            velocity = fartBoost;
            totalFarts++;

            // Normal fart cloud
            const fart = document.createElement('div');
            fart.className = 'fart';
            fart.textContent = fartSounds[Math.floor(Math.random() * fartSounds.length)];
            fart.style.left = plane.offsetLeft + 'px';
            fart.style.top = planeY + 'px';
            gameContainer.appendChild(fart);
            setTimeout(() => fart.remove(), 1200);

            // Play fart sound using SHARED audio context
            try {
                if (!sharedAudioContext) {
                    sharedAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const osc = sharedAudioContext.createOscillator();
                const gain = sharedAudioContext.createGain();
                osc.connect(gain);
                gain.connect(sharedAudioContext.destination);
                osc.frequency.setValueAtTime(120, sharedAudioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(60, sharedAudioContext.currentTime + 0.2);
                osc.type = 'sawtooth';
                gain.gain.setValueAtTime(0.3, sharedAudioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, sharedAudioContext.currentTime + 0.2);
                osc.start();
                osc.stop(sharedAudioContext.currentTime + 0.2);
            } catch(e) {
                console.log('Fart sound failed:', e);
            }
        }

        function triggerFartTornado() {
            // SUPER FART TORNADO POWER BOOST - WILD AND RANDOM!
            const randomBoost = 2 + Math.random() * 2; // Random 2x-4x boost!
            velocity = fartBoost * randomBoost;

            // Create MULTIPLE spinning tornados for chaos!
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const tornado = document.createElement('div');
                    tornado.className = 'tornado';
                    tornado.textContent = 'üå™Ô∏è';
                    tornado.style.left = (plane.offsetLeft + Math.random() * 100 - 50) + 'px';
                    tornado.style.top = (planeY + Math.random() * 100 - 50) + 'px';
                    tornado.style.fontSize = (50 + Math.random() * 80) + 'px'; // Random size!
                    gameContainer.appendChild(tornado);
                    setTimeout(() => tornado.remove(), 2000);
                }, i * 100);
            }

            // LOUD tornado sound (whoosh)
            try {
                if (sharedAudioContext) {
                    const osc = sharedAudioContext.createOscillator();
                    const gain = sharedAudioContext.createGain();
                    osc.connect(gain);
                    gain.connect(sharedAudioContext.destination);
                    osc.frequency.setValueAtTime(300, sharedAudioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(80, sharedAudioContext.currentTime + 0.6);
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(0.5, sharedAudioContext.currentTime); // LOUDER!
                    gain.gain.exponentialRampToValueAtTime(0.01, sharedAudioContext.currentTime + 0.6);
                    osc.start();
                    osc.stop(sharedAudioContext.currentTime + 0.6);
                }
            } catch(e) {}

            // Announce it LOUDLY!
            try {
                if ('speechSynthesis' in window) {
                    speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance("FART TORNADO!");
                    utterance.rate = 0.9; // Slower and clearer
                    utterance.volume = 1.0;
                    utterance.pitch = 1.6; // Very high and exciting!
                    utterance.lang = 'en-US';
                    speechSynthesis.speak(utterance); // No delay - speak immediately!
                    console.log('üå™Ô∏è FART TORNADO! Boost:', randomBoost.toFixed(2) + 'x');
                }
            } catch(e) {}
        }

        // Touch controls
        gameContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            fart();
        });

        gameContainer.addEventListener('click', fart);
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                fart();
            }
        });

        function createObstacle() {
            const obstacle = document.createElement('div');
            obstacle.className = 'obstacle';
            obstacle.textContent = ['üöÅ', 'üõ∏', 'üéà', 'ü¶Ö'][Math.floor(Math.random() * 4)];
            obstacle.style.top = Math.random() * (window.innerHeight - 150) + 50 + 'px';
            const duration = (Math.random() * 1.5 + 3.5) + 's'; // SLOWER: 3.5-5s instead of 2.5-3.5s
            obstacle.style.animationDuration = duration;
            gameContainer.appendChild(obstacle);
            obstacles.push({element: obstacle, scored: false});
            setTimeout(() => {
                obstacle.remove();
                obstacles = obstacles.filter(o => o.element !== obstacle);
            }, parseFloat(duration) * 1000);
        }

        function createStar() {
            const star = document.createElement('div');
            star.className = 'star';

            // 20% chance of TACO (fart tornado power-up!)
            const isTaco = Math.random() < 0.2;
            const emoji = isTaco ? 'üåÆ' : ['‚≠ê', 'üçï', 'üåü', 'üç©', 'üéÅ'][Math.floor(Math.random() * 5)];

            star.textContent = emoji;
            star.style.top = Math.random() * (window.innerHeight - 100) + 50 + 'px';
            const duration = (Math.random() * 1 + 3.5) + 's'; // SLOWER: 3.5-4.5s
            star.style.animationDuration = duration;
            gameContainer.appendChild(star);
            stars.push({element: star, collected: false, isTaco: isTaco});
            setTimeout(() => {
                star.remove();
                stars = stars.filter(s => s.element !== star);
            }, parseFloat(duration) * 1000);
        }

        function checkCollision(element) {
            const planeRect = plane.getBoundingClientRect();
            const elementRect = element.getBoundingClientRect();
            const margin = 25;
            return !(planeRect.right < elementRect.left + margin ||
                     planeRect.left > elementRect.right - margin ||
                     planeRect.bottom < elementRect.top + margin ||
                     planeRect.top > elementRect.bottom - margin);
        }

        function update() {
            if (!gameRunning) return;

            velocity += gravity;
            velocity = Math.max(-20, Math.min(20, velocity));
            planeY += velocity;

            const maxY = window.innerHeight - 80;
            if (planeY < 20) {
                planeY = 20;
                velocity = Math.max(0, velocity * 0.3);
            }
            if (planeY > maxY) {
                planeY = maxY;
                velocity = 0;
                loseLife();
            }

            plane.style.top = planeY + 'px';

            // Star collection
            stars.forEach(star => {
                if (!star.collected && checkCollision(star.element)) {
                    star.collected = true;
                    score += 10;
                    scoreElement.textContent = score;

                    // Check if it's a TACO - trigger FART TORNADO!
                    if (star.isTaco) {
                        // Show TACO POWER popup
                        const popup = document.createElement('div');
                        popup.className = 'pointPopup';
                        popup.textContent = 'TACO POWER!';
                        popup.style.left = star.element.offsetLeft + 'px';
                        popup.style.top = star.element.offsetTop + 'px';
                        gameContainer.appendChild(popup);
                        setTimeout(() => popup.remove(), 1000);

                        triggerFartTornado(); // ACTIVATE!
                    } else {
                        // Show +10 points popup
                        const popup = document.createElement('div');
                        popup.className = 'pointPopup';
                        popup.textContent = '+10';
                        popup.style.left = star.element.offsetLeft + 'px';
                        popup.style.top = star.element.offsetTop + 'px';
                        gameContainer.appendChild(popup);
                        setTimeout(() => popup.remove(), 1000);
                    }

                    star.element.remove();

                    // Play collection sound (happy chime)
                    try {
                        if (sharedAudioContext) {
                            const osc = sharedAudioContext.createOscillator();
                            const gain = sharedAudioContext.createGain();
                            osc.connect(gain);
                            gain.connect(sharedAudioContext.destination);
                            osc.frequency.setValueAtTime(800, sharedAudioContext.currentTime);
                            osc.frequency.setValueAtTime(1000, sharedAudioContext.currentTime + 0.05);
                            gain.gain.setValueAtTime(0.3, sharedAudioContext.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, sharedAudioContext.currentTime + 0.15);
                            osc.start();
                            osc.stop(sharedAudioContext.currentTime + 0.15);
                        }
                    } catch(e) {}

                    // Random encouraging message every 5 stars
                    if (score % 50 === 0 && score > 0) {
                        try {
                            if ('speechSynthesis' in window) {
                                speechSynthesis.cancel(); // Clear pending speech
                                const msg = funMessages[Math.floor(Math.random() * funMessages.length)];
                                const utterance = new SpeechSynthesisUtterance(msg);
                                utterance.rate = 1.0;
                                utterance.volume = 1.0;
                                utterance.pitch = 1.2;
                                utterance.lang = 'en-US';
                                setTimeout(() => {
                                    speechSynthesis.speak(utterance);
                                }, 100);
                                console.log('Encouraging:', msg);
                            }
                        } catch(e) {
                            console.log('TTS encouraging error:', e);
                        }
                    }
                }
            });

            // Obstacle collision
            obstacles.forEach(obstacle => {
                if (!obstacle.scored && checkCollision(obstacle.element)) {
                    obstacle.scored = true;
                    loseLife();
                    obstacle.element.remove();
                } else if (!obstacle.scored) {
                    const obstacleRect = obstacle.element.getBoundingClientRect();
                    const planeRect = plane.getBoundingClientRect();
                    if (obstacleRect.right < planeRect.left - 50) {
                        obstacle.scored = true;
                        score += 5;
                        scoreElement.textContent = score;
                    }
                }
            });
        }

        function loseLife() {
            lives--;
            livesElement.textContent = lives;

            // Explosion
            const explosion = document.createElement('div');
            explosion.className = 'explosion';
            explosion.textContent = 'üí•';
            explosion.style.left = plane.offsetLeft + 'px';
            explosion.style.top = planeY + 'px';
            gameContainer.appendChild(explosion);
            setTimeout(() => explosion.remove(), 800);

            // Play explosion sound (low rumble)
            try {
                if (sharedAudioContext) {
                    const osc = sharedAudioContext.createOscillator();
                    const gain = sharedAudioContext.createGain();
                    osc.connect(gain);
                    gain.connect(sharedAudioContext.destination);
                    osc.frequency.setValueAtTime(150, sharedAudioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, sharedAudioContext.currentTime + 0.3);
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(0.4, sharedAudioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, sharedAudioContext.currentTime + 0.3);
                    osc.start();
                    osc.stop(sharedAudioContext.currentTime + 0.3);
                }
            } catch(e) {}

            // Speak crash message
            try {
                if ('speechSynthesis' in window) {
                    speechSynthesis.cancel(); // Clear any pending speech
                    const msg = crashMessages[Math.floor(Math.random() * crashMessages.length)];
                    const utterance = new SpeechSynthesisUtterance(msg);
                    utterance.rate = 0.8; // Slower for clarity
                    utterance.volume = 1.0; // Max volume
                    utterance.pitch = 1.2; // Higher pitch to stand out
                    utterance.lang = 'en-US';

                    // Wait a tiny bit then speak (helps on some browsers)
                    setTimeout(() => {
                        speechSynthesis.speak(utterance);
                    }, 100);
                    console.log('Speaking:', msg);
                } else {
                    console.log('speechSynthesis not available');
                }
            } catch(e) {
                console.log('TTS error:', e);
            }

            if (lives <= 0) {
                endGame();
            }
        }

        function endGame() {
            gameRunning = false;
            clearInterval(gameLoop);
            stopBackgroundMusic(); // Stop the music
            finalScore.textContent = score;
            totalFartsElement.textContent = totalFarts;
            gameOver.style.display = 'block';

            obstacles.forEach(o => o.element.remove());
            stars.forEach(s => s.element.remove());
            obstacles = [];
            stars = [];
        }

        function startBackgroundMusic() {
            if (!sharedAudioContext || musicInterval) return;

            const melody = [523, 587, 659, 587, 523, 440, 523, 587];  // C D E D C A C D
            const bass = [262, 330, 392, 330, 262, 220, 262, 330];     // Bass notes
            let noteIndex = 0;

            musicInterval = setInterval(() => {
                if (!gameRunning) return;

                try {
                    // Lead melody
                    const lead = sharedAudioContext.createOscillator();
                    const leadGain = sharedAudioContext.createGain();
                    lead.connect(leadGain);
                    leadGain.connect(sharedAudioContext.destination);
                    lead.frequency.value = melody[noteIndex % melody.length];
                    lead.type = 'square';
                    leadGain.gain.setValueAtTime(0.08, sharedAudioContext.currentTime);
                    leadGain.gain.exponentialRampToValueAtTime(0.01, sharedAudioContext.currentTime + 0.3);
                    lead.start();
                    lead.stop(sharedAudioContext.currentTime + 0.3);

                    // Bass
                    const bassOsc = sharedAudioContext.createOscillator();
                    const bassGain = sharedAudioContext.createGain();
                    bassOsc.connect(bassGain);
                    bassGain.connect(sharedAudioContext.destination);
                    bassOsc.frequency.value = bass[noteIndex % bass.length];
                    bassOsc.type = 'sine';
                    bassGain.gain.setValueAtTime(0.06, sharedAudioContext.currentTime);
                    bassGain.gain.exponentialRampToValueAtTime(0.01, sharedAudioContext.currentTime + 0.3);
                    bassOsc.start();
                    bassOsc.stop(sharedAudioContext.currentTime + 0.3);

                    noteIndex++;
                } catch(e) {
                    console.log('Music error:', e);
                }
            }, 350); // Play note every 350ms

            console.log('üéµ Background music started!');
        }

        function stopBackgroundMusic() {
            if (musicInterval) {
                clearInterval(musicInterval);
                musicInterval = null;
            }
        }

        function startGame() {
            // UNLOCK AUDIO FIRST - must be synchronous with user tap on iOS!
            try {
                if (!sharedAudioContext) {
                    sharedAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('‚úÖ Audio context created!', sharedAudioContext.state);
                }

                // CRITICAL: Resume BEFORE playing sound
                if (sharedAudioContext.state === 'suspended') {
                    sharedAudioContext.resume().then(() => {
                        console.log('‚úÖ Audio context resumed!', sharedAudioContext.state);
                    });
                }

                // Play LOUDER AUDIBLE test tone (iOS Safari requires this)
                const testOsc = sharedAudioContext.createOscillator();
                const testGain = sharedAudioContext.createGain();
                testOsc.connect(testGain);
                testGain.connect(sharedAudioContext.destination);
                testOsc.frequency.value = 800;
                testOsc.type = 'sine'; // Cleaner sound
                testGain.gain.setValueAtTime(0.3, sharedAudioContext.currentTime); // LOUDER!
                testGain.gain.exponentialRampToValueAtTime(0.01, sharedAudioContext.currentTime + 0.2);
                testOsc.start(sharedAudioContext.currentTime);
                testOsc.stop(sharedAudioContext.currentTime + 0.2);
                console.log('‚úÖ Test beep played at volume 0.3!');

                // Also try TTS unlock
                if ('speechSynthesis' in window) {
                    const unlockUtterance = new SpeechSynthesisUtterance("Ready!");
                    unlockUtterance.volume = 0.1; // Quiet
                    unlockUtterance.rate = 2.0; // Fast
                    speechSynthesis.speak(unlockUtterance);
                    console.log('‚úÖ TTS unlock attempted');
                }
            } catch(e) {
                console.log('‚ùå Audio unlock failed:', e);
            }

            // Now start the game
            startScreen.style.display = 'none';
            gameContainer.style.display = 'block';
            gameOver.style.display = 'none';
            gameRunning = true;
            score = 0;
            lives = 3;
            planeY = window.innerHeight / 2;
            velocity = 0;
            totalFarts = 0;
            scoreElement.textContent = '0';
            livesElement.textContent = '3';
            plane.textContent = '‚úàÔ∏è';

            setInterval(() => { if (gameRunning) createObstacle(); }, 2500); // Every 2.5 seconds
            setInterval(() => { if (gameRunning) createStar(); }, 1000); // Every 1 second - MORE STARS!

            gameLoop = setInterval(update, 1000 / 60);

            // Start background music!
            setTimeout(() => startBackgroundMusic(), 200);
        }

        function restartGame() {
            startGame();
        }
    </script>
</body>
</html>
